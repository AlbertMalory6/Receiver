================================================================================
              WHY "NOT ENOUGH SAMPLES FOR FULL FRAME" ERROR
================================================================================

CURRENT SITUATION (BROKEN):
================================================================================

INPUT.txt contains: 1000 bits
Receiver expects:   5000 bits  ← MISMATCH!

Transmitted Signal:
┌─────────────────────────────────────────────────────────────────────────┐
│ Component          │ Duration    │ Samples   │ Description              │
├────────────────────┼─────────────┼───────────┼──────────────────────────┤
│ Silent Leader      │ 0.5 sec     │ 22,050    │ Ensures recorder ready   │
│ Preamble (Chirp)   │ 0.01 sec    │ 440       │ Sync pattern             │
│ Data (1000 bits)   │ 1.0 sec     │ 44,000    │ FSK modulated payload    │
│ CRC (8 bits)       │ 0.008 sec   │ 352       │ Error detection          │
├────────────────────┼─────────────┼───────────┼──────────────────────────┤
│ TOTAL TRANSMITTED  │ 1.518 sec   │ 66,842    │ Actual signal length     │
└─────────────────────────────────────────────────────────────────────────┘

Recording Buffer:
┌─────────────────────────────────────────────────────────────────────────┐
│ Pre-allocated:     │ ~2.5 sec    │ 110,924   │ (signal + 1 sec margin)  │
└─────────────────────────────────────────────────────────────────────────┘

What Receiver Tries to Do:
┌─────────────────────────────────────────────────────────────────────────┐
│ Preamble detected at sample 26,214 (t=0.594s)                           │
│                                                                          │
│ Tries to read DATA starting at ~26,214:                                 │
│   Expected: 5000 bits + 8 CRC = 5008 bits                               │
│   Samples needed: 5008 × 44 = 220,352 samples                           │
│                                                                          │
│ Recording ends at: 110,924 samples                                      │
│ Available from 26,214 onwards: 110,924 - 26,214 = 84,710 samples        │
│                                                                          │
│ SHORTFALL: 220,352 - 84,710 = 135,642 samples!  ❌                      │
└─────────────────────────────────────────────────────────────────────────┘


VISUAL TIMELINE:
================================================================================

Time (seconds):  0.0         0.5      0.594               1.518      2.51
                 │           │        │                   │          │
                 ▼           ▼        ▼                   ▼          ▼
Recording:  ═════╬═══════════╬════════╬═══════════════════╬══════════╬═════
            │    │           │        │                   │          │     │
            │    │  Silent   │Preamble│       Data        │   CRC    │Margin
            │    │  Leader   │        │    (1000 bits)    │ (8 bits) │     │
            │    │           │        │                   │          │     │
            │    └───────────┴────────┘                   └──────────┘     │
            │                │                                              │
            │                │                                              │
            │                └─ NCC Peak Detected Here                      │
            │                  (sample 26,214)                              │
            │                          │                                    │
            │                          ▼                                    │
            │                  ┌───────────────────────┐                    │
            │                  │ Receiver tries to read│                    │
            │                  │ 220,352 samples here! │                    │
            │                  │                       │                    │
            │                  │ (for 5008 bits)       │                    │
            │                  │                       │                    │
            │                  │         But only has  │                    │
            │                  │         84,710 samples│                    │
            │                  │         available!    │                    │
            │                  └───────────────────────┘                    │
            │                          │                                    │
            │                          ▼                                    │
            └──────────────────────────╬────────────────────────────────────┘
                                       │
                                    ERROR!
                              "Not enough samples"


THE CORE PROBLEM:
================================================================================

namespace FSK {
    constexpr int payloadBits = 5000;  // ← HARDCODED!
                                       // ← This expects 5000 bits always
    constexpr int crcBits = 8;
    constexpr int totalFrameBits = payloadBits + crcBits;  // = 5008
    constexpr int totalFrameDataSamples = totalFrameBits * samplesPerBit;
                                                            // = 220,352
}

But INPUT.txt only has 1000 bits!

So the signal is only:
    (1000 + 8) × 44 = 44,352 samples
    
Not the expected:
    (5000 + 8) × 44 = 220,352 samples


SAMPLE CALCULATION:
================================================================================

┌─────────────────────────────────────────────────────────────────────────┐
│                         TRANSMITTED SIGNAL                              │
├─────────────────────────────────────────────────────────────────────────┤
│  Silent Leader:    22,050 samples                                       │
│  Preamble:            440 samples                                       │
│  Data (1000 bits): 44,000 samples  (1000 × 44)                          │
│  CRC (8 bits):        352 samples  (8 × 44)                             │
│  ─────────────────────────────────                                      │
│  TOTAL:           66,842 samples (1.516 seconds)                        │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                       RECEIVER EXPECTATIONS                             │
├─────────────────────────────────────────────────────────────────────────┤
│  Preamble detection at sample:  26,214                                  │
│  Frame data starts around:      26,214 + offset correction              │
│                                                                          │
│  Expected data size:                                                    │
│    Payload: 5000 bits = 220,000 samples                                 │
│    CRC:        8 bits =     352 samples                                 │
│    Total:   5008 bits = 220,352 samples                                 │
│                                                                          │
│  Recording ends at:             110,924 samples                         │
│  Available from 26,214:          84,710 samples                         │
│                                                                          │
│  DEFICIT: 220,352 - 84,710 = 135,642 samples  ❌                        │
└─────────────────────────────────────────────────────────────────────────┘


WHY MULTIPLE PREAMBLE DETECTIONS?
================================================================================

Your output shows 10 detections. Let's analyze:

Detection #1:  t=0.594s  NCC=0.467  ← REAL preamble
Detection #2:  t=0.672s  NCC=0.400  ← 78ms later (echo/reflection)
Detection #3:  t=0.776s  NCC=0.352  ← 104ms later (echo)
Detection #4:  t=0.789s  NCC=0.377  ← 13ms after #3 (same echo)
Detection #5:  t=0.816s  NCC=0.356  ← 27ms later (fade of echo)
...

Visual representation of NCC over time:

NCC Value
  1.0 │
      │
  0.8 │
      │
  0.6 │
      │
  0.4 │              ╱╲
      │            ╱    ╲        ╱╲    ╱╲  ╱╲
  0.2 │        ╱╲╱        ╲    ╱    ╲╱    ╲    ╲╱╲
      │    ╱╲╱              ╲╱                      ╲
  0.0 ├────────────────────────────────────────────────────
      │    │  │    │       │  │    │  │  │    │
      0.0 0.5 0.6  0.7    0.8 0.9  1.0 1.1 1.2 1.5 seconds
           │                │  │    │  │  │
           └─ Real preamble │  │    │  │  │
                            │  │    │  │  │
                            └──┴────┴──┴──┴─ Acoustic echoes/reflections

Causes:
1. Sound bounces off walls → delayed copies of preamble
2. Hysteresis too short (220 samples = 5ms) → detects echo peaks
3. Threshold too low (0.35) → picks up weak echoes


THE FIX:
================================================================================

┌─────────────────────────────────────────────────────────────────────────┐
│                        SOLUTION 1: ADAPTIVE SIZE                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  // Remove hardcoded size                                               │
│  namespace FSK {                                                        │
│      // DELETE: constexpr int payloadBits = 5000;                       │
│      constexpr int crcBits = 8;                                         │
│                                                                          │
│      // Use dynamic functions instead                                   │
│      inline int totalFrameBits(int payloadBits) {                       │
│          return payloadBits + crcBits;                                  │
│      }                                                                   │
│      inline int totalFrameDataSamples(int payloadBits) {                │
│          return totalFrameBits(payloadBits) * samplesPerBit;            │
│      }                                                                   │
│  }                                                                       │
│                                                                          │
│  // In main():                                                          │
│  int payloadBits = bits_to_send.size();  // Get actual size             │
│  processor.analyzeRecording(recording, payloadBits);  // Pass it        │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                   SOLUTION 2: PREVENT FALSE DETECTIONS                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  A. Increase hysteresis (wait longer before confirming peak):           │
│     Old: (i - peakSampleIndex) > (FSK::preambleSamples / 2)  // 220    │
│     New: (i - peakSampleIndex) > FSK::preambleSamples        // 440    │
│                                                                          │
│  B. Raise detection threshold:                                          │
│     Old: NCC_DETECTION_THRESHOLD = 0.35                                 │
│     New: NCC_DETECTION_THRESHOLD = 0.40                                 │
│                                                                          │
│  C. Add frame spacing check:                                            │
│     if (detectionCount == 0 ||                                          │
│         (i - lastDetectionSample) > totalFrameDataSamples) {            │
│         // Only detect if far enough from last frame                    │
│     }                                                                    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘


AFTER THE FIX:
================================================================================

Time (seconds):  0.0         0.5      0.594          1.518         2.51
                 │           │        │              │             │
                 ▼           ▼        ▼              ▼             ▼
Recording:  ═════╬═══════════╬════════╬══════════════╬═════════════╬═════
            │    │  Silent   │Preamble│     Data     │    CRC      │Margin
            │    │  Leader   │        │  (1000 bits) │  (8 bits)   │     │
            │    │           │        │              │             │     │
            │    └───────────┴────────┘              └─────────────┘     │
            │                │                                            │
            │                └─ NCC Peak Detected                         │
            │                  (sample 26,214)                            │
            │                          │                                  │
            │                          ▼                                  │
            │                  ┌───────────────────────┐                  │
            │                  │ Receiver now reads:   │                  │
            │                  │                       │                  │
            │                  │ 44,352 samples        │                  │
            │                  │ (for 1008 bits)       │                  │
            │                  │                       │                  │
            │                  │ Has: 84,710 available │                  │
            │                  │                       │                  │
            │                  │ 84,710 > 44,352  ✅   │                  │
            │                  │                       │                  │
            │                  │ SUCCESS!              │                  │
            │                  └───────────────────────┘                  │
            └──────────────────────────────────────────────────────────────┘


CRC VALIDATION:
================================================================================

How to verify CRC is working correctly:

┌─────────────────────────────────────────────────────────────────────────┐
│  STEP 1: Test with Known Vector                                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Python:                           C++:                                 │
│  data = "10110100"                 std::vector<bool> test =             │
│  crc = calc_crc8(data)             {1,0,1,1,0,1,0,0};                   │
│  # Result: 0xA7                    uint8_t crc =                        │
│                                    FSK::calculateCRC8(test);            │
│                                    // Should be: 0xA7                   │
│                                                                          │
│  ✅ If both give 0xA7 → CRC implementation is correct!                  │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│  STEP 2: Test Error Detection                                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Original:  "10110100" → CRC: 0xA7                                      │
│  Corrupted: "10110101" → CRC: 0x5D (different!)                         │
│                                                                          │
│  ✅ CRC detects the single bit error!                                   │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│  STEP 3: End-to-End Test                                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. Generate INPUT.txt: "1010..." (1000 bits)                           │
│  2. Transmit → Receiver demodulates → OUTPUT.txt                        │
│  3. Compare INPUT.txt vs OUTPUT.txt:                                    │
│                                                                          │
│     Case A: Perfect match + CRC passed                                  │
│     → ✅ Everything working correctly!                                  │
│                                                                          │
│     Case B: Bits differ but CRC passed                                  │
│     → ❌ CRC implementation is broken!                                  │
│                                                                          │
│     Case C: Bits differ and CRC failed                                  │
│     → ✅ CRC working (detected errors correctly)                        │
│     → ⚠️  But synchronization has issues                                │
└─────────────────────────────────────────────────────────────────────────┘


QUICK ACTION PLAN:
================================================================================

[1] Apply fixes from fix_receiver.cpp:
    □ Remove hardcoded payloadBits = 5000
    □ Add dynamic size calculation
    □ Pass actual bit count to analyzer
    □ Increase hysteresis to full preamble length
    □ Raise threshold to 0.40

[2] Test CRC implementation:
    □ Run: python test_crc.py
    □ Verify test vector matches (0xA7 for "10110100")
    □ Check error detection rate >99%

[3] Run fixed receiver:
    □ Should see: "Samples available: 84710, need: 44352 ✅"
    □ Should see: "Total frames detected: 1"
    □ Should see: "✅ CRC OK!"

[4] Validate output:
    □ Run: python test_crc.py
    □ Should see: "✅ PERFECT MATCH!"

================================================================================
                              END OF EXPLANATION
================================================================================

For complete implementation details, see:
  - fix_receiver.cpp       (Code fixes)
  - test_crc.py            (CRC testing utility)
  - PROBLEM_DIAGNOSIS.md   (Detailed analysis)

